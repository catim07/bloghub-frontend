import{t as u,c as y,n as O,g as x,e as X,a as I,m as S,b as h}from"./index-SpF_zyS9.js";import{d as j,h as C,h as R,f as q,i as E,j as U,k as V,o as B,p as G,q as J,r as K,s as P,l as Q,u as Z,v as $,w as tt,x as et,y as nt,z as st}from"./index-SpF_zyS9.js";function M(e,s){const n=+u(e)-+u(s);return n<0?-1:n>0?1:n}function k(e){return y(e,Date.now())}function _(e,s,n){const[r,t]=O(n?.in,e,s),f=r.getFullYear()-t.getFullYear(),i=r.getMonth()-t.getMonth();return f*12+i}function w(e){return s=>{const r=(e?Math[e]:Math.trunc)(s);return r===0?0:r}}function F(e,s){return+u(e)-+u(s)}function T(e,s){const n=u(e,s?.in);return n.setHours(23,59,59,999),n}function W(e,s){const n=u(e,s?.in),r=n.getMonth();return n.setFullYear(n.getFullYear(),r+1,0),n.setHours(23,59,59,999),n}function b(e,s){const n=u(e,s?.in);return+T(n,s)==+W(n,s)}function N(e,s,n){const[r,t,f]=O(n?.in,e,e,s),i=M(t,f),a=Math.abs(_(t,f));if(a<1)return 0;t.getMonth()===1&&t.getDate()>27&&t.setDate(30),t.setMonth(t.getMonth()-i*a);let l=M(t,f)===-i;b(r)&&a===1&&M(r,f)===1&&(l=!1);const m=i*(a-+l);return m===0?0:m}function p(e,s,n){const r=F(e,s)/1e3;return w(n?.roundingMethod)(r)}function v(e,s,n){const r=x(),t=n?.locale??r.locale??X,f=2520,i=M(e,s);if(isNaN(i))throw new RangeError("Invalid time value");const a=Object.assign({},n,{addSuffix:n?.addSuffix,comparison:i}),[l,m]=O(n?.in,...i>0?[s,e]:[e,s]),d=p(m,l),Y=(I(m)-I(l))/1e3,o=Math.round((d-Y)/60);let D;if(o<2)return n?.includeSeconds?d<5?t.formatDistance("lessThanXSeconds",5,a):d<10?t.formatDistance("lessThanXSeconds",10,a):d<20?t.formatDistance("lessThanXSeconds",20,a):d<40?t.formatDistance("halfAMinute",0,a):d<60?t.formatDistance("lessThanXMinutes",1,a):t.formatDistance("xMinutes",1,a):o===0?t.formatDistance("lessThanXMinutes",1,a):t.formatDistance("xMinutes",o,a);if(o<45)return t.formatDistance("xMinutes",o,a);if(o<90)return t.formatDistance("aboutXHours",1,a);if(o<S){const c=Math.round(o/60);return t.formatDistance("aboutXHours",c,a)}else{if(o<f)return t.formatDistance("xDays",1,a);if(o<h){const c=Math.round(o/S);return t.formatDistance("xDays",c,a)}else if(o<h*2)return D=Math.round(o/h),t.formatDistance("aboutXMonths",D,a)}if(D=N(m,l),D<12){const c=Math.round(o/h);return t.formatDistance("xMonths",c,a)}else{const c=D%12,g=Math.trunc(D/12);return c<3?t.formatDistance("aboutXYears",g,a):c<9?t.formatDistance("overXYears",g,a):t.formatDistance("almostXYears",g+1,a)}}function H(e,s){return v(e,k(e),s)}export{M as compareAsc,y as constructFrom,k as constructNow,j as differenceInCalendarDays,_ as differenceInCalendarMonths,F as differenceInMilliseconds,N as differenceInMonths,p as differenceInSeconds,T as endOfDay,W as endOfMonth,C as format,R as formatDate,v as formatDistance,H as formatDistanceToNow,q as formatters,E as getDayOfYear,U as getISOWeek,V as getISOWeekYear,B as getWeek,G as getWeekYear,J as isDate,b as isLastDayOfMonth,K as isValid,P as lightFormatters,Q as longFormatters,Z as startOfDay,$ as startOfISOWeek,tt as startOfISOWeekYear,et as startOfWeek,nt as startOfWeekYear,st as startOfYear,u as toDate};
